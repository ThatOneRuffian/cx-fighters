package main
import "glfw"
import "inputs"

func gameLoop()() {
    var program i32 = gl.CreateProgram() // create program object to apply shaders and 
    
    initSprites() 	// create sprites and their starting location
   
    for bool.not(glfw.ShouldClose("window")) && gameWindow.Running {
		updateGameTimers() // frame rate, animation, and tracking
		
		updateActions() // update game data based on player inputs
		updateSprites() // update sprite positions based on their velocity
		
        if loopLimiter.limitReached {
            
			prepWindowGl(program)  // reload gl window attributes
			renderSprites()
			
            glfw.PollEvents()  			// poll keyboard and mouse events
            glfw.SwapBuffers("window")  // update screen buffer
        }
    }
    str.print("Closing game")
}

func updateActions(){
	window.updateWindow(&gameWindow) // parse player input meant for the current window 
	inputs.updatePlayer(&synthCat)
}

func updateSprites(){
	updateSprite(&synthCat)
	updateSprite(&yarnBall)	
}

func initSprites() {
    background = createBackgroundSprite()
    synthCat  = createSynthCatSprite()
    yarnBall = createYarnBallSprite()
    
    synthCat.position.y = -0.8    // what are the units on these, %? 
    yarnBall.position.x = 0.0
    yarnBall.position.y = -0.8
    yarnBall.velocity.y = 0.3
    yarnBall.velocity.x = 0.6

    initBricks()
}

func renderSprites(){
	drawSprite(background)
    drawSprite(synthCat)
    
    // render array of sprites
    drawSprites(bricks)

}

func prepWindowGl(program i32){
	gl.UseProgram(program)
	gl.Clear(i32.bitor(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT))
	gl.Enable(gl.TEXTURE_2D)
	gl.Disable(gl.DITHER)
	gl.Disable(gl.POINT_SMOOTH)
	gl.Disable(gl.LINE_SMOOTH)
	gl.Disable(gl.POLYGON_SMOOTH)
	gl.Hint(gl.POINT_SMOOTH, gl.DONT_CARE)
	gl.Hint(gl.LINE_SMOOTH, gl.DONT_CARE)
	gl.Hint(gl.POLYGON_SMOOTH_HINT, gl.DONT_CARE)
	gl.Disable(gl.MULTISAMPLE_ARB)

	gl.TexEnvi(gl.TEXTURE_ENV, gl.TEXTURE_ENV_MODE, gl.MODULATE)
	gl.Disable(gl.DEPTH_TEST)

	gl.ClearColor(1.0, 1.0, 1.0, 1.0)
	gl.ClearDepth(1.0D)
	gl.DepthFunc(gl.LEQUAL)

	gl.Enable(gl.BLEND)
	gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	gl.DepthMask(true)

	gl.MatrixMode(gl.PROJECTION)
	gl.LoadIdentity()

	gl.MatrixMode(gl.MODELVIEW)
	gl.LoadIdentity()
}

func updateGameTimers() {
	// update game timers

	currentTime = glfw.GetTime()
	loopLimiter = LoopLimiter.update(loopLimiter, currentTime)    
	animationLimiter = LoopLimiter.update(animationLimiter, currentTime)
	loopTracker = LoopTracker.update(loopTracker, currentTime)
}


// ============== Old reference code ================

func initBricks() {
    var startPos Vector2D
    var increment f32
    increment = 128.0 / 1024.0
    startPos.x = -0.55
    startPos.y = -0.6

    for i:=0; i<8; i=i+1 {
        startPos.x = startPos.x + increment
        bricks = append(bricks, createBrickSprite(startPos))
    }
}

func updateBall(ball Sprite)(out Sprite) {
    if ball.position.x >= 0.9 || ball.position.x <= -0.9 {
        ball.velocity.x = ball.velocity.x*-1.0
        if ball.position.x > 0.9 {
            ball.position.x = 0.9
        } else {
            ball.position.x = -0.9
        }
    }
    
    if ball.position.y >= 0.9 || ball.position.y <= -0.9 {
        ball.velocity.y = ball.velocity.y*-1.0
        if ball.position.y > 0.9 {
            ball.position.y = 0.9
        } else {
            ball.position.y = -0.9
        }
    }

    if spriteTop(ball) > spriteBottom(synthCat) && spriteLastTop(ball) < spriteLastBottom(synthCat) {
        if spriteRight(ball) >= spriteLeft(synthCat) && spriteLeft(ball) <= spriteRight(synthCat) {
            ball.position.y = spriteBottom(synthCat) - ball.height / 2.0
            ball.velocity.y = ball.velocity.y*-1.0
        }
    }

    ball.lastPosition = ball.position
    out = ball
}
